# 数据处理

## 缺失值与异常值

### 缺失值

#### 类型

1. 随机丢失：丢失概率与数据本身无关，依赖于其他不含缺失值的变量/缺失低于5％可以这么认为，采用成列删除
2. 完全随机丢失：不依赖其他变量，不影响样本无偏性/常数计算，EM估计
3. 非随机丢失：丢失取决于本身属性，如在调查收入情况时高收入人群通常不愿透露自身收入

对第三种情况删除缺失值可能导致偏差，填充也需要格外谨慎

#### 处理方法

1. 删除（该样本，该变量）

2. 填充：常数填充（-1，0，均值，条件均值/从与该样本有相同决策属性的样本中均值）

   ​			就近补齐：找到完整数据中最相似的一个用其值填充，单难以定义相似

   ​			K-means法：利用某种距离度量确定最近的k个样本，将对应值加权平均填充（数值数据使用欧式距离，曼哈顿距离等；分类数据使用汉明距离），缺点是耗时，且数据维度较高时准确性下降

   ​			回归预测填充：当变量不是线性相关时会导致有估计的偏差

   ​			期望值最大化方法（EM）

   ​			特殊值：把缺失当做一种取值，常用于离散数据

### 异常值

#### 检测

3σ原则：符合正态分布的数据将在3σ外的数据剔除

箱线图：![](C:\Users\Lenovo\Desktop\68747470733a2f2f356230393838653539353232352e63646e2e736f687563732e636f6d2f696d616765732f32303138303230312f61396266626131393964373134323533396435316266353065613739613336652e706e67.png)

- 中位数（ Q2 / 50 th 百分位数）：数据集的中间值
- 下四分位数（ Q1 / 25 th 百分位数）：最小数（非「最小值」）和数据集中位数之间的中间值
- 上四分位数（ Q3 / 75 th 百分位数）：数据集中位数和最大数（非「最大值」）之间的中间值
- 四分位间距（ IQR ）：上下四分位数之间的距离
- 上限：Q3＋1.5*IQR
- 下限：Q1－1.5*IQR

上下限之外的点即离群点（异常值），可舍去

#### 处理

1. 删除（成列，成对）

2. 视为缺失值处理

3. 均值修正

4. 盖帽法：默认凡小于百分之1分位数和大于百分之99分位数的值将会被百分之1分位数和百分之99分位数替代

5. 分箱法：对数据进行进一步归类分组，以包容异常值

   ![](https://img-blog.csdnimg.cn/img_convert/d50b3d58d24fc46534b60ea9880e943a.png)

	6. 插补法

## 插值方法

​	受环境限制无法获取较多的数据点，但已知的数据点是经过实测得来的，精度较高。因此我们需要用一个初等函数在通过已知数据点的情况下，对已知数据自变量的取值范围内的其他点进行预测，这就是数据插值

与拟合不同的是，插值函数一定经过数据点

### 线性插值

将需要插值的地方两侧最近的两个数据点连线，计算方程后代入数据点

$ L(x)=y_k + \frac{y_{k+1}-y_k}{x_{k+1}-x_k}(x-x_k)$

### 最近邻插值

距离插值地最近数据代替

### 拉格朗日插值

设有n+1个插值节点，x~0~—x~n~，对应数据值为y~0~—y~n~

记$l_i(x)=\prod\limits_{j=0,j\neq i}^n\frac{x-x_j}{x_i-x_j}$

插值多项式为：$L_n(x)=\sum\limits_{i=0}^ny_il_i(x)$

插值余项：$R_n(x)=f(x)-L_n(x)=\frac{f^{(n+1)}(x)}{(n+1)!}\prod\limits_{i=0}^n(x-x_i)\leq\frac{max|f^{(n+1)}(x)|}{(n+1)!}\prod\limits_{i=0}^n(x-x_i)$

缺点：需要利用所有数据，一旦数据变动需要全部重新计算

### 牛顿插值

![image-20230808104220439](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230808104220439.png)

牛顿插值的原理为原函数基于差商的展开，两者余项相同，但牛顿法更具一般性，对离散和导数不存在时均适用

### **三次Hermite插值**

更具有约束力的插值方法，要求插值函数在插值点不仅和原数据相同，还要求导数相同，其中三次Hermite插值应用最多

![image-20230808105814177](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230808105814177.png)

### 三次样条插值

将每个小区间段上都建立三次函数作为插值函数，且曲线光滑，原函数，一次二次导数均连续

对n+1个节点建立n个三次方程，出现4n个未知数

方程满足样本点在插值函数上，且函数连续，有2n个

n-1个内部点一阶导数连续，使前后区间的函数一阶导数相等，有n-1个

二阶导数连续，有n-1个

此时有4n-2个，差的两个依靠边界条件给出

设在[x~i~，x~i+1~]上的函数为S~i~（x），记h~i~=x~i+1~-x~i~，m~i~=S~i~^''^(x~i~)

自然边界：m~0~=0 m~n~=0

![](https://pic2.zhimg.com/80/v2-ebf2b5a738b991728f22855a8a215ca5_720w.webp)

![](https://pic2.zhimg.com/80/v2-8db3c613d3ced90f51155cbc3e1fc675_720w.webp)

夹持边界：首尾分段函数在外侧端点处一阶导数值确定方程左侧变为

![](https://pic1.zhimg.com/80/v2-a0d578a6ffb02b0556fab2556b622c9c_720w.webp)

非扭结边界：![image-20230808113214146](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230808113214146.png)

![](https://pic2.zhimg.com/80/v2-9ba4ca62d82aa5bbc4627f5439c27f2d_720w.webp)

结果：![image-20230808113254789](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230808113254789.png)



## 数据拟合

一般根据以下三个指标判断拟合好坏

残差平方和SSE

回归平方和SSR

总离差平方和SST

有SST=SSE+SSR

拟合优度$R^2=\frac{SSR}{SST}=1-\frac{SSE}{SST}$越接近1，误差越小，拟合效果越好

由于SST取决于数据本身，与拟合无关，则拟合应当使得SSE最小

### 最小二乘法

假设函数形式，待定初等函数的系数，以这些系数为变量列出SSE，求解min SSE,方法为SSE对系数向量求偏导使其等于0

一元拟合假设函数形式为g(**b**)，每项数据残差为r~i~ ，残差向量为**r(b)**，其中有n个待定系数b~j~，有m个样本点，则求解
$$
\nabla g=J(b)^Tr(b)=0
$$
其中 **J** 是**r**对**b**的雅可比矩阵

常用方法有牛顿法，高斯牛顿法等

（工作量巨大，建议使用软件）

## 数据线性化

1. 泰勒展开

   对系统$f(x(t),t)$，系统平衡点定义为$\dot x(t)=0$,在平衡点对x泰勒展开可以忽略二阶及以上的项

2. 指数对数函数，简单求ln或e为底数即可

## 数据变换

归一化：min-max![](https://pic1.zhimg.com/80/v2-a574ab86e4980fa344cc30baf74a914c_720w.webp)

​				z-score（标准化）![](https://pic3.zhimg.com/80/v2-11879a3fdc6b832ab14db641454f3dce_720w.webp)

​				log函数	$x^{'}=\frac{log_{10}x}{log_{10}max(x)}$

​				反正切函数	x' = atan(x)*(2/pi)		映射到[-1,1]

​				向量归一化（2范数归一化）	$x^{'}_{ij}=\frac{x_{ij}}{\sqrt{\sum\limits_{i=1}^nx_{ij}^2}} $

​				均值

## 数据降维

### PCA 主成分分析（见评价类模型）

### SVD 奇异值分解

类似于PCA，但不是从协方差矩阵求特征值，而是直接求原始数据矩阵的奇异值
$$
对于任意m×n矩阵A（m\textgreater n）, 则存在R^n的一组标准正交基v_i和R_m的一组标准正交基u_i\\
使得Av_i=\sigma_iu_i,其中\sigma_i为A的一个奇异值\\
则A=U\Sigma V^T,其中\Sigma 是m×n矩阵，由n个奇异值依照对角线从大到小排列并在下方添加m-n行0组成\\
并且UU^T=VV^T=I\\
则AA^T=U\Sigma^2 U^T,A^TA=V\Sigma^2 V^T\\
只要求出两个矩阵的特征值从大到小排列并开方就得到n个奇异值
$$

#### 利用奇异值进行数据降维

可以从行或列进行数据降维，以行为例，选取最大的k个奇异值对应的标准正交向量u~i~组成矩阵后转置左乘到A上，完成主成分提取

整体压缩：按奇异值大小展开$A=\sum\limits_{i=1}^n\sigma_iu_iv_i^T$其中每一项都是一个m×n矩阵，选取前k个

### FA 因子分析

同PCA相似，第一步进行检验看是否能进行主成分或因子分析

与PCA相反的是，FA从因子层面反向构建原始变量

$X=AF+\epsilon$ 其中X为原始变量，系数矩阵A称为因子载荷矩阵，F为公共因子向量，ε的元素为X每个元素的特殊因子组成的向量

满足：公共因子数量不多于原始变量数量，公共因子与特殊因子不相关，各个公共因子不相关且方差为1，各个特殊因子不相关

#### 求解因子载荷矩阵

一般使用主成分分析法，其他方法有主因子法，极大似然估计法

主成分分析法：计算协方差矩阵的特征值，并从大到小排列，记对应单位特征向量为e~1~，e~2~...e~k~，则

$A=(\sqrt{\lambda_1}e_1,\sqrt{\lambda_2}e_2,...,\sqrt{\lambda_k}e_k)(\sqrt{\lambda_1}e_1,\sqrt{\lambda_2}e_2,...,\sqrt{\lambda_k}e_k)^T$    其中

$a_{ij}=\sqrt{\lambda_i}e_{ij}$

#### 因子载荷矩阵的旋转

为了便于解释因子含义，需要进行旋转，使得每个载荷具有一定区分度

真难搞了    [旋转方法]([因子分析法之因子旋转_区区大蠢猫的博客-CSDN博客](https://blog.csdn.net/weixin_39437355/article/details/111480165))

#### 因子得分

比如把得到的因子作为自变量来做回归分析，对样 本进行分类或评价，这就需要我们对公共因子进行测度，即给出公共因子的值

因子得分函数：$F=\beta X$

记$D=diag(\sigma_1^{-2},\sigma_2^{-2}...)$,σ为A的奇异值

则$\hat F=(A^TD^{-1}A)^{-1}A^TD^{-1}X$

#### 与主成分法的区别与联系

![image-20230809104632860](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230809104632860.png)

### ICA 独立成分分析

与PCA和FA不同，ICA不依赖于正态分布

令x=As，要求A^-1^ =W，s间互相独立

预处理：中心化：x，s分别减去自身均值向量，在计算完ICA后再加回

​				白化：![image-20230809111632101](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230809111632101.png)

#### FastICA迭代算法

![image-20230809112422230](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230809112422230.png)

收敛指前后的权值指向同一方向

### LDA 线性判别降维

与PCA类似但最后将数据体现更好的分类特征

计算每一个类别数据的协方差矩阵S~i~

计算类内散布矩阵$S_w=\sum S_i$

计算类间散布矩阵$S_b=\sum\limits_{i=1}^cn_i(u_i-u)(u_i-u)^T$, 其中c为类别数，n~i~为每一类样本数，u~i~为每一类样本均值，u表示样本总均值

计算$S_w^{-1}S_b$的特征值，取出前k个较大的特征值代表的特征向量组成系数矩阵W，则降维投影为Y=W^T^X

缺点：当不是高斯分布时，效果不是很好

​			降维后维数最多为类别数-1，当原始维数高而分类数少时算法不适用

### MDS 多维标度变换

与PCA等不同，MDS希望降维后数据间的距离得到一定保持

让m×d维度降为d‘维度

![image-20230809113102921](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230809113102921.png)

第一步的d~ij~为原始数据样本i和j间的距离，d~ji~=d~ij~

这种方法解不唯一，通常人为限制Z矩阵的向量相加为0，即中心化

### ISOmap 等距特征映射

isomap算法是基于前面所讲的MDS算法，不同之处在于isomap用图中两点的最短路径距离替代了MDS中欧式空间的距离，这样能更好的拟合流形体数据

MDS中使用的为欧式距离，如果数据整体呈现低维度的折叠形态，ISO使用的距离为两点间沿着低维度的最短距离

首先构造邻域图G，指定一个合适的值K或ε，对于数据点i附近距离最近的K个点或距离小于ε的所有点，在图中连接这些点与点i，并设置边权为两点间距离

利用图论的最短路算法，计算G中任意两点间的沿着低维的最短距离，建立距离矩阵

使用此矩阵应用MDS法计算

